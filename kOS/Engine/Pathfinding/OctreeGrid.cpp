/******************************************************************/
/*!
\file      OctreeGrid.cpp
\author    Yeo See Kiat Raymond, seekiatraymond.yeo, 2301268
\par       seekiatraymond.yeo@digipen.edu
\date      October 3, 2025
\brief     This file contains the grid generated by the Octree system,
			holding the graph to be accessed and determines how the
			octree should be created.


Copyright (C) 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents without the
prior written consent of DigiPen Institute of Technology is prohibited.
*/
/********************************************************************/

#include "OctreeGrid.h"

namespace Octrees {
	Octree::Octree() {

	}

	Octree::Octree(float minNodeSize, Graph _graph) {
		graph = _graph;

		CalculateBounds();
		CreateTree(minNodeSize);
		auto start2 = std::chrono::high_resolution_clock::now();
		GetEmptyLeaves(&root);
		auto end2 = std::chrono::high_resolution_clock::now();
		auto duration2 = std::chrono::duration_cast<std::chrono::microseconds>(end2 - start2);
		//std::cout << "Elapsed time FOR GETTING LEAVES: " << duration2.count() << " microseconds\n";
		GetEdges();
		//std::cout << "EDGES: " << graph.edges.size() << std::endl;

		//for (Edge edge : graph.edges) {
		//	std::cout << "EDGE A: " << edge.a->octreeNode.bounds.center.x << ", " << edge.a->octreeNode.bounds.center.y << ", " << edge.a->octreeNode.bounds.center.z << std::endl;
		//	std::cout << "EDGE B: " << edge.b->octreeNode.bounds.center.x << ", " << edge.b->octreeNode.bounds.center.y << ", " << edge.b->octreeNode.bounds.center.z << std::endl;
		//}
	}

	void Octree::GetEmptyLeaves(OctreeNode* node) {

		if (node->IsLeaf() && !node->objects.size()) {
			emptyLeaves.push_back(*node);
			graph.AddNode(*node);
			return;
		}

		if (node->children.empty()) {
			return;
		}

		for (OctreeNode& child : node->children) {
			GetEmptyLeaves(&child);
		}

		for (int i = 0; i < node->children.size(); ++i) {
			for (int j = i + 1; j < node->children.size(); ++j) {
				if (i == j)
					continue;

				graph.AddEdge(&node->children[i], &node->children[j]);
				//std::cout << "EDGE A: " << graph.edges.back().a->octreeNode.bounds.center.x << ", " << graph.edges.back().a->octreeNode.bounds.center.y << ", " << graph.edges.back().a->octreeNode.bounds.center.z << std::endl;
				//std::cout << "EDGE B: " << graph.edges.back().b->octreeNode.bounds.center.x << ", " << graph.edges.back().b->octreeNode.bounds.center.y << ", " << graph.edges.back().b->octreeNode.bounds.center.z << std::endl;
			}
		}
	}

	void Octree::CreateTree(float minNodeSize) {
		ecs::ECS* ecs = ecs::ECS::GetInstance();
		root = OctreeNode(bounds, minNodeSize);
		for (const auto& id : ecs->GetEntitySignatureData()) {
			ecs::BoxColliderComponent* boxCollider = ecs->GetComponent<ecs::BoxColliderComponent>(id.first);

			if (!boxCollider)
				continue;

			root.Divide(id.first);
		}
	}

	void Octree::CalculateBounds() {
		ecs::ECS* ecs = ecs::ECS::GetInstance();
		glm::vec3 minBound(std::numeric_limits<float>::max(), std::numeric_limits<float>::max(), std::numeric_limits<float>::max()),
			maxBound(std::numeric_limits<float>::lowest(), std::numeric_limits<float>::lowest(), std::numeric_limits<float>::lowest());

		glm::vec3 boundCenter(0.f, 0.f, 0.f);

		for (const auto& id : ecs->GetEntitySignatureData()) {
			ecs::BoxColliderComponent* boxCollider = ecs->GetComponent<ecs::BoxColliderComponent>(id.first);
			ecs::TransformComponent* transform = ecs->GetComponent<ecs::TransformComponent>(id.first);

			if (!boxCollider)
				continue;

			if (boxCollider->box.bounds.min.x + transform->WorldTransformation.position.x < minBound.x) {
				minBound.x = boxCollider->box.bounds.min.x + transform->WorldTransformation.position.x;
			}
			if (boxCollider->box.bounds.min.y + transform->WorldTransformation.position.y < minBound.y) {
				minBound.y = boxCollider->box.bounds.min.y + transform->WorldTransformation.position.y;
			}
			if (boxCollider->box.bounds.min.z + transform->WorldTransformation.position.z < minBound.z) {
				minBound.z = boxCollider->box.bounds.min.z + transform->WorldTransformation.position.z;
			}
			if (boxCollider->box.bounds.max.x + transform->WorldTransformation.position.x > maxBound.x) {
				maxBound.x = boxCollider->box.bounds.max.x + transform->WorldTransformation.position.x;
			}
			if (boxCollider->box.bounds.max.y + transform->WorldTransformation.position.y > maxBound.y) {
				maxBound.y = boxCollider->box.bounds.max.y + transform->WorldTransformation.position.y;
			}
			if (boxCollider->box.bounds.max.z + transform->WorldTransformation.position.z > maxBound.z) {
				maxBound.z = boxCollider->box.bounds.max.z + transform->WorldTransformation.position.z;
			}
		}

		boundCenter.x = (minBound.x + maxBound.x) / 2.f;
		boundCenter.y = (minBound.y + maxBound.y) / 2.f;
		boundCenter.z = (minBound.z + maxBound.z) / 2.f;
		glm::vec3 boundSize = glm::vec3(1.f, 1.f, 1.f) * std::max(std::max(maxBound.x - minBound.x, maxBound.y - minBound.y), maxBound.z - minBound.z) * 0.6f;
		glm::vec3 boundMin = boundCenter - boundSize, boundMax = boundCenter + boundSize;

		bounds.center = boundCenter;
		bounds.size = boundSize;
	}

	void Octree::GetEdges() {
		for (OctreeNode leaf : emptyLeaves) {
			for (OctreeNode otherLeaf : emptyLeaves) {
				if (leaf == otherLeaf)
					continue;

				if (leaf.bounds.Intersects(otherLeaf.bounds)) {
					graph.AddEdge(&leaf, &otherLeaf);
				}
			}
		}
	}

	//OctreeNode Octree::FindClosestNode(glm::vec3 position) {
	//	FindClosestNode(root, position);
	//}

	//OctreeNode Octree::FindClosestNode(OctreeNode node, glm::vec3 position) {
	//	Octree found;

	//	for (int i = 0; i < node.children.size(); ++i) {
	//		if(node.children[i].bounds)
	//	}
	//}

	OctreeNode Octree::GetClosestNode(glm::vec3 position) {
		OctreeNode closestNode;

		float closestDistanceSqr = std::numeric_limits<float>().max();

		for (Node node : graph.nodes) {
			OctreeNode octreeNode = node.octreeNode;
			float distanceSqr = glm::length2(octreeNode.bounds.center - position);

			if (distanceSqr < closestDistanceSqr) {
				closestDistanceSqr = distanceSqr;
				closestNode = octreeNode;
			}
		}

		return closestNode;
	}
}